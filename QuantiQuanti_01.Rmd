---
title: "Overview"
output: pdf_document
---

# 1. Distribution of sensory attributes


Let import the dataset, do a summary of it and identify quantitative variables (sensory attributes); we're gonna work only on this variables for moment.
Two options to import : 

- read.table() : default `quote = " "'", which means that double and single quotation marks are considered as separators outside of perfume names here have single quotation marks and we donâ€™t want them to be considered as separators so we only indicate double quotation marks in the quote argument. 
```{r}
experts <- read.table(file="data/perfumes_qda_experts.csv",header=TRUE, sep=",",quote="\"")
```

- read.csv() :
```{r}
experts <- read.csv(file = "data/perfumes_qda_experts.csv" )
```

To get a first approach, we use summary() :

```{r}
summary(experts)
```
Remember the nature of the data set and of variables `Product`, `Session`, `Panelist` and `Rank`. They're must be categorical, do the transformation. 

```{r}
experts$Product <- as.factor(experts$Product)
experts$Panelist <- as.factor(experts$Panelist)
experts$Session <- as.factor(experts$Session)
experts$Rank <- as.factor(experts$Rank)
```

*Tips :* use a loop to save time 
```{r}
for (col in colnames(experts[,1:4])){
  experts[, col] <- as.factor(experts[, col])
}
```

## Histogram

The empirical distribution of a variable is the set of values (or modalities) taken by this variable, and their associated numbers. However, the variables being continuous, it is very rare to have the same value twice for two different individuals.

We therefore choose to make a grouping in classes.

### CRAN functions 

The first point is to represent one variable. Choose it and plot its histogram.

```{r}
hist(experts$Spicy)
```

Here, a lot of information is available to us. The first one is an idea of the representation of the scores given by the judges to the attribute. We that a lot of notes are between 0 and 1. The rest is more homogeneous. As explain previously, this distribution is cut in classes. The cut is set by the argument `breaks`. By default, it is set with the _Sturges_ method, which is the most recommended in the most of the cases. If you specify manually this number,  make sure the number is not too high or not too low.

```{r}
hist(experts$Spicy, 
     breaks=50)
```

We notice however that this histogram represents the frequencies of observations on the ordinate, or more precisely the number of observations of each class. It is the argument `freq = True` that gives us this representation. But you sometimes histograms are plot using frequency density, the frequency per unit for the data in each class. It is calculated by dividing the frequency by the class width. We change the argument `probability` to `probability = TRUE` to have this representation.

```{r}
hist(experts$Spicy, 
     breaks=50, 
     probability=TRUE)
```
*Aesthetic tips* : be more precise and write the title in the *main()* argument
```{r}
hist(experts$Spicy, 
     breaks=50, 
     probability=TRUE,
     main = "Histogram of Spicy")
```
### Using the `ggplot2` package

The mecanisme is based on layers : 
- ggplot for data;
- aes (aesthetics) for variables;
- geom_ for the type of representation.

Do the histogram of one variable: 

```{r}
library(ggplot2)

ggplot(experts)+
  aes(x=Spicy)+
  geom_histogram()
```
Here you just informed the x-axis because by default the y-axis is the frequencies but if you want to plot the graph of the histogram of the density you can inquire the y-axis like `y=..density..`. 

```{r}
ggplot(experts)+
  aes(x=Spicy, y=..density..)+
  geom_histogram()
```

In the layer `aes()` we can use different argument to modify the appareance or add more information. The most natural is to differenciate the distribution of the variable between products in using the `fill()` argument. 

```{r}
ggplot(experts)+
  aes(x=Spicy, y=..density.., fill=Product)+
  geom_histogram()
```
*Aesthetic tips* : to add a title and change the axes's titles, use the layer `labs()`
```{r}
ggplot(experts)+
  aes(x=Spicy, y=..density.., fill=Product)+
  geom_histogram() +
  labs(title="Histogram of Spicy" ,x="Spicy values", y = "Frequency")
```

## Density

### CRAN functions 

This notion of density is introduce here, it allows to restrict the frequencies of the classes between 0 and 1. Plot the density for one sensory attributes with the `density()` function of R.  

```{r}
d <- density(experts$Spicy) 
plot(d, main = "Density of Spicy") 
```

The histogram of frenquency density can be superposed to the curve. First, plot the histogram of the density for one sensory attribute and add the line of this density. To superpose a line on a graph you can use `lines()`. Take care, to appear together, both functions must be running together. 

```{r}
hist(experts$Vanilla, probability = TRUE, main = "Histogram of Vanilla")
lines(density(experts$Vanilla))
```

We can also compare two estimate density of two different variables. Create a graph with the lines of the density of two sensory attributes. To be distinct, lines must be in different colors (use the `col` argument) :

```{r}
plot(density(experts$Vanilla), col="blue", main="Vanilla and Floral density")
lines(density(experts$Floral), col="red")
```
It's important to put a legend to identify which lines is for which attribute using a legend. Add the `legend()` function : 
- identify the position of the legend with the `x` and `y` arguments; 
- put names in a vector with `legend`;
- inform the color of lines in legend with `col`; 
- inform the type for lines appearing in the legend. 

```{r}
plot(density(experts$Vanilla), col="blue", main="Vanilla and Floral density")
lines(density(experts$Floral), col="red")

legend(x=10, y=0.2, legend=c("Vanilla", "Floral"),col=c("blue", "red"), lty=1)
```

### `ggplot2` functions 

The representation is the line  of the density so we use `geom_density()`. 

```{r}
ggplot(experts) + 
  aes(x=Vanilla) + 
  geom_density()+
  labs(title="Density of Vanilla" ,x="Vanilla values", y = "Density") 
```
To get the density on the plot of the histogram : 
```{r}
ggplot(experts) + 
 aes(x=Vanilla, y=..density..) + 
 geom_histogram()+
 geom_density() +
 labs(title="Density of Vanilla" ,x="Vanilla values", y = "Density")
```
The plot of the density can be differentiate between products if we inform it with `color`.

```{r}
ggplot(experts) + 
  aes(x=Vanilla, color=Product) + 
  geom_density() +
  labs(title="Density of Vanilla for each product" ,x="Vanilla values", y = "Density")
```
*Aesthetic tips* : to have an other visualization, we can use `fill` and not `color` to have the shade of lines and we can change the gradient of colors of lines in informing the parameter `alpha` in `geom_histogram()`

```{r}
ggplot(experts) + 
  aes(x=Vanilla, fill=Product) + 
  geom_density(alpha=0.5)  +
  labs(title="Density of Vanilla for each product" ,x="Vanilla values", y = "Density")
```
## Descriptors

### Creation of a dataframe

Now that we have an idea of the variable density, we can introduce the notion of descriptors. We now want to know which notes "cut" the population into two groups of equal size. The median is the value separating the higher half from the lower half of a data sample, a population, or a probability distribution. For a data set, it may be thought of as "the middle" value. To generalize, we have the notion of quantile, which are cut points dividing the observations in a sample in the same way. 

We want to calculate the mean, the standard deviation, the first quantile and the third quantile for each sensory attributes in the data set `experts` and save them in a data frame. 

First, create an empty data frame with `data.frame()`. We must to inform column's names and the type of variable in them. 

```{r}
descriptors <- data.frame("mean"=double(), "sd"=double(), "median"=double(), "q1"=double(), "q3"=double())
```

By using a loop, add a new line, who represents descriptors, for each sensory attribute with `rbind()`. 
```{r}
for (a in 5:16){
  me <- mean(experts[,a])
  sd <- sqrt(var(experts[,a]))
  med <- quantile(experts[,a], 0.5)
  q1 <- quantile(experts[,a], 0.25)
  q3 <- quantile(experts[,a], 0.75)
  descriptors <- rbind(descriptors, c(me, sd, med, q1, q3))
}
```

Inform names of columns with `colnames()` and names of rows with `rownames()`.  
```{r}
colnames(descriptors) <- c("mean", "sd", "median", "q1", "q3")
rownames(descriptors) <- colnames(experts[,5:16])
```

### Visualization of descriptors 

#### Boxplot 

##### CRAN function

These descriptors can be visualized, plot the box-plot of each sensory attributes. You can plot them in the same window by using the function `par()`. 

```{r}
par(mfrow=c(1,3))

for (attribute in colnames(experts[,5:7])){
  boxplot(experts[,attribute], main = attribute)
}
```

Do it on three attributes and add the line corresponding to the mean with `abline()`
```{r}
par(mfrow=c(1,3))

for (attribute in colnames(experts[,5:7])){
  boxplot(experts[,attribute], main = attribute)
  abline(h=mean(experts[,attribute]))
}
```
##### ggplot2 function

By using `ggplot2`, you can represent the same graphs with the function `geom_boxplot()`. To get several graphs on the same window, you can use the `gridExtra` library. It's useful only for ggplot's graphs. You must to store each graph in variables and with the function `grid.arrange()` where you inform variables and the number of rows (`nrow`) and columns (`columns`), you can plot graphs in the same window. 
```{r}
library(gridExtra)

g1 <-  ggplot(experts)+
          aes(y=Spicy)+
          geom_boxplot()

g2 <-  ggplot(experts)+
          aes(y=Heady)+
          geom_boxplot()

g3 <-  ggplot(experts)+
          aes(y=Fruity)+
          geom_boxplot()

grid.arrange(g1,g2,g3, nrow=1, ncol=3)
```
#### Density

Let's illustrate these descriptors in complementary of the density. 

##### CRAN function 

We can use bascis function of R and plot the density again and adding the mean and the first and third quantile.

```{r}
d<-density(experts$Vanilla)

# Plot the line
plot(d, main="Vanilla Distribution and quantiles")
q25 <- which.max(cumsum(d$y/sum(d$y)) >= 0.25)
q95 <- which.max(cumsum(d$y/sum(d$y)) >= 0.95)

# Plot the shading
polygon(c(-5, d$x[1:q25], d$x[q25]), c(0, d$y[1:q25], 0), col = 'lightblue')
polygon(c(d$x[q95], d$x[d$x > d$x[q95]], 15),c(0, d$y[d$x > d$x[q95]], 0),col = "lightblue")

# Plot the vline for mean
abline(v=mean(experts$Vanilla))
text(mean(experts$Vanilla),0.2, "mean", pos=2)

# Plot the vline for Q3
abline(v=d$x[q95])
text(d$x[q95],0.2, "Q3", pos=2)

# Plot the vline for Q1
abline(v=d$x[q25])
text(d$x[q25],0.2, "Q1", pos=2)
```

##### ggplot function 

Let's begin with the mean. 

```{r}
mean_vanilla <- mean(experts$Vanilla)

ggplot(experts)+
  aes(x=Vanilla)+
  geom_density()+
  geom_vline(xintercept=mean_vanilla)
```

Do the same with the first and third quantile. 

```{r}
q1 <- quantile(experts$Vanilla, 0.25)
q2 <- quantile(experts$Vanilla, 0.75)

ggplot(experts)+
  aes(x=Vanilla)+
  geom_density()+
  geom_vline(xintercept=q1)+
  geom_vline(xintercept=q2)
```
*Aesthetic tips* : use the `fill` argument in `geom_density()` to give color to the graph 
```{r}
ggplot(experts)+
  aes(x=Vanilla)+
  geom_density(fill='red', alpha=0.5)+
  geom_vline(xintercept=mean_vanilla)
```
# 2. Product effect

The point of interest in sensory analysis is the product effect on each sensory attributes. To begin, plot the density for one sensory attribute and for three product.

To begin, by using `dplyr` library, we want to create a new data frame from `experts` who gives in addition to the values, means of one sensory attribute for three products. Some function from `dplyr` is used :
- select() to select columns, 
- filter() to filter rows by condition, 
- group_by() to create group on which we can summarize information, 
- mutate() to add a column.
Between each function there is the operator " %>% " which allows chain manipulation. 

```{r}
library(dplyr)

df <- experts %>%  
  # Select 3 products and 1 sensory attribute
  select(c(Product, Floral)) %>% 
  filter(Product == "J'adore ET" | Product == "Angel" | Product == "Chanel N5" ) %>%
  # Add the mean's column
  group_by(Product) %>% 
  mutate(mu=mean(Floral))
```

Next, thanks to the column created for means, you can plot the density of one attribute and add the line for the mean without store them in variables. Plot this for each product. 
```{r}
ggplot(df) + 
  aes(x=Floral, color=Product) + 
  geom_density() + 
  geom_vline(aes(xintercept=mu, color=Product)) + 
  labs(title="Density of Floral according three products")
```

Each sensory attributes has different dispersion depending on the product youâ€™re focusing on, it's the product effect.

The next part focus on the box-plots of the same sensory attribute. Using the same libraries, build three box-plot for three products.

```{r}
ggplot(df) + 
  aes(y=Floral, x= Product, color=Product) + 
  geom_boxplot() + 
  labs(title="Boxplot of Floral according three products")
```
# 3. Differences between products 

To have a better understanding of this differences between products, we use the precedent box-plots, where we add a segment between each means with `stat_summary()`. Choose three products and one sensory attributes and run this code :

```{r}
ggplot(df)+
  aes(y=Floral, x= Product, color=Product) + 
  geom_boxplot() +
  stat_summary(mapping=aes(group=1), fun=mean, geom="line", color="black") + 
  stat_summary(fun=mean, geom="point")
```

These segments are equivalent to a `distance` between all the product, in the sensory attribute point of view. Try to have these visualization for four sensory attributes and for each, three products. So you need to plot four graphs, for this use the `grid.arrange` function. 

Like before, create a data frame with informations we need :

```{r}
df <- experts %>%  
  select(c(Product, Floral, Citrus, Spicy, Heady)) %>% 
  filter(Product == "J'adore ET" | Product == "Angel" | Product == "Chanel N5" )
```

Next, plot the graphs. Note you can delete legend of axis with the ggplot function `theme()`. For example, you informe : 
- `axis.title.x=element_blank()`to delete the legend the x-axis;
- `axis.text.x=element_blank()` to delete the text for the x-axis. 

```{r}
# First sensory attribute
a1 <- ggplot(df)+
  aes(y=Floral, x= Product, color=Product)+geom_boxplot() + 
  stat_summary(fun=mean, geom="line", aes(group=1), color="black") + 
  stat_summary(fun=mean, geom="point")+
  # Delete the x-axis:
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank())

# Second sensory attribute
a2 <- ggplot(df)+
  aes(y=Spicy, x= Product, color=Product)+geom_boxplot() + 
  stat_summary(fun=mean, geom="line", aes(group=1), color="black") + 
  stat_summary(fun=mean, geom="point")+
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank())

# Third sensory attribute
a3 <- ggplot(df)+
  aes(y=Citrus, x= Product, color=Product)+geom_boxplot() + 
  stat_summary(fun=mean, geom="line", aes(group=1), color="black") + 
  stat_summary(fun=mean, geom="point")+
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank())

# Fourth sensory attribute
a4 <- ggplot(df)+
  aes(y=Heady, x= Product, color=Product)+geom_boxplot() + 
  stat_summary(fun=mean, geom="line", aes(group=1), color="black") + 
  stat_summary(fun=mean, geom="point")+
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank())

grid.arrange(a1, a2, a3,a4, ncol=2, nrow = 2)
```

Now, do exactly the same without plotting the box-plots:

```{r}
a1 <- ggplot(df)+
  aes(y=Floral, x= Product, color=Product)+ 
  stat_summary(fun=mean, geom="line", aes(group=1), color="black") + 
  stat_summary(fun=mean, geom="point")+
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank())

a2 <- ggplot(df)+
  aes(y=Citrus, x= Product, color=Product) + 
  stat_summary(fun=mean, geom="line", aes(group=1), color="black") + 
  stat_summary(fun=mean, geom="point")+
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank())

a3 <- ggplot(df)+
  aes(y=Spicy, x= Product, color=Product) + 
  stat_summary(fun=mean, geom="line", aes(group=1), color="black") + 
  stat_summary(fun=mean, geom="point")+
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank())

a4 <- ggplot(df)+aes(y=Heady, x= Product, color=Product) + 
  stat_summary(fun=mean, geom="line", aes(group=1), color="black") + 
  stat_summary(fun=mean, geom="point")+
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank())

grid.arrange(a1, a2, a3, a4, ncol=2, nrow = 2)
```

To finish, we want to plot same graphs but without the variance. This very important step makes it possible to compare individuals with each other in relation to a reference value which is the one in 0. Moreover, by dividing by the standard deviation, each individual has the same weight which is 1.

To do, you need to divide values by the standard deviation. 

```{r}
for (attribute in colnames(df)[-1]){
  df[, attribute] <- df[, attribute]/sd(df[, attribute])
}
```

Next, plot the same graphs :
```{r}
a1 <- ggplot(df)+
  aes(y=Floral, x= Product, color=Product)+ 
  stat_summary(fun=mean, geom="line", aes(group=1), color="black") + 
  stat_summary(fun=mean, geom="point")+
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank())

a2 <- ggplot(df)+
  aes(y=Citrus, x= Product, color=Product) + 
  stat_summary(fun=mean, geom="line", aes(group=1), color="black") + 
  stat_summary(fun=mean, geom="point")+
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank())

a3 <- ggplot(df)+
  aes(y=Spicy, x= Product, color=Product) + 
  stat_summary(fun=mean, geom="line", aes(group=1), color="black") + 
  stat_summary(fun=mean, geom="point")+
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank())

a4 <- ggplot(df)+
  aes(y=Heady, x= Product, color=Product) + 
  stat_summary(fun=mean, geom="line", aes(group=1), color="black") + 
  stat_summary(fun=mean, geom="point")+
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank())

grid.arrange(a1, a2, a3, a4, ncol=2, nrow = 2)
```

We have finally 4 univariate analysis of the mean differences between all the products for each attributes. For example, _Chanel N5_ and _Angel_ are closer than _J'adore ET_ in Spicy perception. They have a shorter "distance" between them. 

We can summary these graphics in four _4x4_ matrix with the distance mean-mean for each product. To get it, start to get the data frame of means of three sensory attributes for three products which the function `summarise` from `dplyr`. 

```{r}
means <- df %>% group_by(Product) %>% summarise(
  mean_Spicy=mean(Spicy),
  mean_Citrus=mean(Citrus),
  mean_Floral=mean(Floral)
)
```

Do the same matrix of means but for 8 sensory attributes and for 8 products. 

```{r}
df.means <- experts %>%  
  select(c(Product, Floral, Citrus, Spicy, Heady, Fruity, Green, Vanilla, Woody)) %>% 
  filter(Product == "J'adore ET" | Product == "Angel" | Product == "Chanel N5" | Product == "Coco Mademoiselle"| Product == "Aromatics Elixir"| Product == "CinÃ©ma"| Product == "J'adore EP"| Product == "Shalimar")

for (attribute in colnames(df.means)[-1]){
  df.means[, attribute] <- df.means[, attribute]/sd(df.means[, attribute])
}

means.V2 <- df.means %>% group_by(Product) %>% summarise(
  mean_Spicy=mean(Spicy),
  mean_Citrus=mean(Citrus),
  mean_Floral=mean(Floral), 
  mean_Heady=mean(Heady), 
  mean_Fruity=mean(Fruity), 
  mean_Green=mean(Green), 
  mean_Vanilla=mean(Vanilla), 
  mean_Woody=mean(Woody)
)
```

# 4. Notion of metric

Next, calculate the distances-matrix for each sensory attributes.

```{r}
spicy.matrix <- as.matrix(dist(means.V2$mean_Spicy))
citrus.matrix <- as.matrix(dist(means.V2$mean_Citrus))
floral.matrix <- as.matrix(dist(means.V2$mean_Floral))
heady.matrix <- as.matrix(dist(means.V2$mean_Heady))
fruity.matrix <- as.matrix(dist(means.V2$mean_Fruity))
green.matrix <- as.matrix(dist(means.V2$mean_Green))
Vanilla.matrix <- as.matrix(dist(means.V2$mean_Vanilla))
woody.matrix <- as.matrix(dist(means.V2$mean_Woody))
```

Try to combine 3 of them in order to visualize simultaneously.

```{r}
a1 <- ggplot(means.V2)+
  aes(x = mean_Spicy, y=mean_Citrus, color=Product)+
  geom_path(aes(group=1),color="black")+
  geom_point()

a2 <- ggplot(means.V2)+
  aes(x = mean_Spicy, y=mean_Floral, color=Product)+
  geom_path(aes(group=1),color="black")+
  geom_point()

a3 <- ggplot(means.V2)+
  aes(x = mean_Citrus, y=mean_Floral, color=Product)+
  geom_path(aes(group=1),color="black")+
  geom_point()

grid.arrange(a1, a2, a3, ncol=2, nrow = 2)
```

A negative slope between two sensory attributes can be traduce like a negative linear relation, and conversely. This is the notion of correlation, it's a standardized form of covariance. You can observe the sign of values and compare them with the previous graphs.

```{r}
means.variables <- data.frame(means.V2, row.names = 1)
cov.att <- cov(means.variables)
```

We can save information about these attributes without products and the dispersion can be traduce with distances between us. Use the function `dist()` to calculate distances.

```{r}
dist.prod <- as.matrix(dist(means.variables))
```

# 5. Structure 

With the data frame of means built just before, we get the two matrix of distances between products `dist.prod` and the matrix of co-variance attributes `cov.att`.  

`heatmap()` function is used to visualize values of a matrix in colors, columns and rows are ordered before and that's why we can already find somes structures. Do it on the both matrix and try to find structures.

```{r}
heatmap(cov.att)
heatmap(dist.prod)
```

*Functions used : heatmap()*

# 6. Inertia 

With these formulas, we can calculate inertia on both matrix. If you scale them, the inertia must be equal to the dimension of them (here 3). 

```{r}
Products_sc_Mat <- as.matrix(dist(scale(dist.prod))^2)
sum(Products_sc_Mat)/(2*dim(Products_sc_Mat)[1]*(dim(Products_sc_Mat)[1]-1))

Att_sc_Mat <- as.matrix(dist(scale(cov.att))^2)
sum(Att_sc_Mat)/(2*dim(Att_sc_Mat)[1]*(dim(Att_sc_Mat)[1]-1))
```

We can decompose inertia, as we can decompose our distance matrix in block regarding the heatmap. With the same methode, calculate the inertia of one group and for others : 

On the covariance matrix :
```{r}
G1 <- as.data.frame(cov.att) %>% select(mean_Citrus, mean_Floral, mean_Fruity, mean_Green)
G2 <- as.data.frame(cov.att) %>% select(mean_Spicy, mean_Heady, mean_Woody, mean_Vanilla)

Att_G1_sc_Mat <- as.matrix(dist(scale(G1))^2)
inertia.G1 <- sum(Att_G1_sc_Mat)/(2*dim(Att_G1_sc_Mat)[1]*(dim(Att_G1_sc_Mat)[1]-1))

Att_G2_sc_Mat <- as.matrix(dist(scale(G2))^2)
inertia.G2 <- sum(Att_G2_sc_Mat)/(2*dim(Att_G2_sc_Mat)[1]*(dim(Att_G2_sc_Mat)[1]-1))

inertia.G1+inertia.G2
```
On the matrix of distances between products : 
```{r}
G1 <- as.data.frame(dist.prod) %>% select("Aromatics Elixir", Shalimar, "Chanel N5", Angel)
G2 <- as.data.frame(dist.prod) %>% select(CinÃ©ma, "Coco Mademoiselle", "J'adore EP", "J'adore ET")

Att_G1_sc_Mat <- as.matrix(dist(scale(G1))^2)
inertia.G1 <- sum(Att_G1_sc_Mat)/(2*dim(Att_G1_sc_Mat)[1]*(dim(Att_G1_sc_Mat)[1]-1))

Att_G2_sc_Mat <- as.matrix(dist(scale(G2))^2)
inertia.G2 <- sum(Att_G2_sc_Mat)/(2*dim(Att_G2_sc_Mat)[1]*(dim(Att_G2_sc_Mat)[1]-1))

inertia.G1+inertia.G2
```

*Functions used : sum(), dim(), scale()*

# 7. PCA

## FactoMineR

Using the `PCA()` function from FactoMineR, do the method on the matrix of means of attributes and print the coordinates of individuals and variables.

```{r}
library(FactoMineR)
res<-PCA(scale(means.variables), graph = FALSE, scale.unit = F)
res$ind$coord
res$var$coord
```

## Decomposition with svd() 

Now, we gonna do the PCA on the same matrix but manually and using the `svd()` function that does the decomposition of the matrix.

```{r}
svd <- svd(scale(means.variables))
diag <- diag(svd$d)

#Verification
svd$u%*%diag%*%t(svd$v)
scale(as.matrix(means.variables))

#Individuals coordinates
scale(means.variables)%*%svd$v
#Variables coordinates
t(scale(means.variables))%*%svd$u/sqrt(dim(means.variables)[1])

#Comparate with PCA()
res$ind$coord
res$var$coord
```

## Using Nipals algorithm

```{r}
NIPALS <- function(X){
  X = as.matrix(X)
  N = nrow(X)
  M = ncol(X)
  
  D = diag(1/N, N)
  Xini = X
  qrX=qr(X)
  rang = qrX$rank
  vec=matrix(0,nrow=M,ncol=rang) 
  t=X[,1]
  i=1
  
  p=t(X)%*%t%*%(1/(t(t)%*%t))
  p=p/as.numeric(sqrt(t(p)%*%p))
  print(rang)
  while (i<rang+1) {
    norm=1
    while(norm>0.000001){
      t=(X%*%p)%*%(1/(t(p)%*%p))
      p2=t(X)%*%t%*%(1/(t(t)%*%t))
      p2=p2/as.numeric(sqrt(t(p2)%*%p2))
      diff=p2-p
      norm=t(diff)%*%diff
      p=p2
      print(p)
      print(i)
    }
    vec[,i]=p
    X=X-(t%*%t(p))
    i=i+1
  }
  return(vec)
}

NIPALS(means.variables)
svd(means.variables)$v
```

# 7. Supplementary informations 

Now, we know how is performed the PCA and how we get the coordinates of individuals or variables. To a better understanding of results, including supplementary information is very important and technically not complicated.

## Supplementary variables 
 
As PCA only uses continuous variables in the calculation of the distances between individuals, categorical variables can only be considered as supplementary. For continuous variables, determining whether they are illustrative or not is arbitrary, and depends on the point of view adopted. Often, continuous variables are considered as supplementary if they are from a different nature. 

>>>>>>> exemple ajout var supp 

## Supplementary individuals

We can use supplementary individuals to a better understanding of structures. For example, adding supplementary individuals that you already know characteristics is appropriate to compare new products. This requires knowledge and expertise that is external and specific to the study context.

>>>>>>> exemple ajout ind supp 

# 8. weighted PCA

Here is an application of weighted PCA with MFA and the dataset wine
```{r}
library("FactoMineR")
library("factoextra")

data(wine)

# We keep actives variables
wine_quanti <- wine[, -c(1,2,30,31)]

group1 <- wine_quanti[, 1:5]
group2 <- wine_quanti[, 6:8]
group3 <- wine_quanti[, 9:18]
group4 <- wine_quanti[, 19:27]

# PCA on each group
res.pca1 <- PCA(group1)
res.pca2 <- PCA(group2)
res.pca3 <- PCA(group3)
res.pca4 <- PCA(group4)

# First eigen values of each PCA
egv1 <- res.pca1$eig[1]
egv2 <- res.pca2$eig[1]
egv3 <- res.pca3$eig[1]
egv4 <- res.pca4$eig[1]

# Vector of weight
w <- c(1/c(rep(egv1,5),rep(egv2,3),rep(egv3,10),rep(egv4,9) ))
res.pca.pon <- PCA(wine_quanti, col.w = w)

coord_pca_pond <- res.pca.pon$ind$coord

res.pca.pon$eig
svd.triplet(scale(wine_quanti))
PCA(wine_quanti)$svd

```

